f(pars)
## Run multivariate proposal MCMC
if(rerun){
output <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=mvrPars,
OPT_TUNING=0.2)
chain <- read.csv(output$file)
} else {
chain <- read.csv("test_multivariate_chain.csv")
}
source('~/.active-rstudio-document', echo=TRUE)
plot(coda::as.mcmc(chain))
output <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=NULL,
OPT_TUNING=0.2)
chain <- read.csv("test_univariate_chain.csv")
chain <- chain[chain$sampno > 10000,]
samps <- sample(unique(chain$sampno),1000)
i <- 10
convert_names <- which(colnames(chain) %in% c("prob",paste0("prob.",1:(length(times)))))-1
tmp_pars <- get_index_pars(chain, samps[i])
names(tmp_pars)[convert_names] <- "prob"
omg <- gaussian_process_model(tmp_pars, times)
plot(omg,type='l')
lines(prob_infection,col="red")
preds <- matrix(0, nrow=length(samps),ncol=length(omg))
for(i in seq_along(samps)){
tmp_pars <- get_index_pars(chain, samps[i])
names(tmp_pars)[convert_names] <- "prob"
omg <- gaussian_process_model(tmp_pars, times)
preds[i,] <- omg
#lines(omg,type='l',col=i)
}
lines(prob_infection,col="red",lwd=2)
quants <- apply(preds, 2, function(x) quantile(x, c(0.025,0.5,0.975)))
plot(quants[3,],type='l',ylim=c(0,0.005))
lines(quants[2,])
lines(quants[1,])
lines(prob_infection,col="red",lwd=2)
plot(quants[3,],type='l',ylim=c(0,0.02))
lines(quants[2,])
lines(quants[1,])
lines(prob_infection,col="red",lwd=2)
plot(coda::as.mcmc(chain))
## MCMC
mcmcPars1 <- c("iterations"=100000,"popt"=0.44,"opt_freq"=5000,
"thin"=10,"adaptive_period"=50000,"save_block"=1000)
mcmcPars2 <- c("iterations"=100000,"popt"=0.234,"opt_freq"=5000,
"thin"=10,"adaptive_period"=50000,"save_block"=1000)
## Get random starting values
startTab <- generate_viable_start_pars(parTab,obs_dat,
create_posterior_func,
gaussian_process_model,
prior_func_use)
covMat <- diag(nrow(startTab))
mvrPars <- list(covMat,2.38/sqrt(nrow(startTab[startTab$fixed==0,])),w=0.8)
f <- create_posterior_func(startTab, data=obs_dat, PRIOR_FUNC=prior_func_hinge_gp,
INCIDENCE_FUNC=gaussian_process_model)
f(pars)
output <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars1,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=NULL,
OPT_TUNING=0.2)
chain <- read.csv(output$file)
chain <- chain[chain$sampno >= mcmcPars1["adaptive_period"],2:(ncol(chain)-1)]
covMat <- cov(chain)
covMat <- diag(nrow(startTab))
mvrPars <- list(covMat,2.38/sqrt(nrow(startTab[startTab$fixed==0,])),w=0.8)
bestPars <- get_best_pars(chain)
startTab$values <- bestPars
output1 <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars2,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=mvrPars,
OPT_TUNING=0.2)
chain <- read.csv(output1$file)
chain <- read.csv("test_univariate_chain.csv")
chain <- chain[chain$sampno > 10000,]
samps <- sample(unique(chain$sampno),1000)
i <- 10
convert_names <- which(colnames(chain) %in% c("prob",paste0("prob.",1:(length(times)))))-1
tmp_pars <- get_index_pars(chain, samps[i])
names(tmp_pars)[convert_names] <- "prob"
omg <- gaussian_process_model(tmp_pars, times)
plot(omg,type='l')
lines(prob_infection,col="red")
preds <- matrix(0, nrow=length(samps),ncol=length(omg))
for(i in seq_along(samps)){
tmp_pars <- get_index_pars(chain, samps[i])
names(tmp_pars)[convert_names] <- "prob"
omg <- gaussian_process_model(tmp_pars, times)
preds[i,] <- omg
#lines(omg,type='l',col=i)
}
lines(prob_infection,col="red",lwd=2)
quants <- apply(preds, 2, function(x) quantile(x, c(0.025,0.5,0.975)))
plot(quants[3,],type='l',ylim=c(0,0.02))
lines(quants[2,])
lines(quants[1,])
lines(prob_infection,col="red",lwd=2)
obs_t
obs_times
## Parameters
parTab <- read.csv("~/Documents/GitHub/ct_inference/pars/parTab_test_seir.csv")
parTab[parTab$names == "beta","fixed"] <- 1
parTab[parTab$names == "rho","fixed"] <- 0
parTab[parTab$names == "rho","values"] <- 0.03
parTab[parTab$names == "nu","fixed"] <- 0
parTab[parTab$names == "nu","values"] <- 3
parTab[parTab$names == "t0","values"] <- 0
parTab[parTab$names == "t0","fixed"] <- 1
pars <- parTab$values
names(pars) <- parTab$names
## Observation times
obs_times <- seq(50,120,by=25)
#obs_times <- c(35, 70,105)
ages <- 1:max(obs_times)
times <- seq(0,max(obs_times),by=1)
## Epidemic cannot start after first observation time
parTab[parTab$names == "t0",c("upper_bound","upper_start")] <- min(obs_times)
## Specify process models
prior_func_use <- prior_func_hinge_gp
incidence_func <- solveSEIRModel_rlsoda_wrapper
## Number sampled per time
n_per_samp <- 2000
n_overall <- length(obs_times)*n_per_samp
## Probability of infection
pars["sigma"] <- 1/pars["incubation"]
pars["gamma"] <- 1/pars["infectious"]
pars["beta"] <- pars["R0"]*pars["gamma"]
## Simulate probability of infection
prob_infection <- incidence_func(pars, times)
#mat <- matrix(rep(times, each=length(times)),ncol=length(times))
#dist <- abs(apply(mat, 2, function(x) x-times))
#mus <- rep(0, length(times))
#nusq <- 10
#rhosq <- 0.001
#K <- nusq * exp(-rhosq * (dist)^2)
#diag(K) <- diag(K) + 0.01
#k <- mvtnorm::rmvnorm(1, mean=mus, sigma=K)[1,]
#ps <- 1/(1+exp(-k))
#prob_infection <- (ps/sum(ps))*pars["overall_prob"]
#plot(prob_infection)
## Simulate infection times
inf_times <- simulate_infection_times(n_per_samp,prob_infection)
## Simulate viral loads/ct values
viral_loads <- simulate_viral_loads(inf_times, times, pars,
additional_detect_process = TRUE,
convert_ct=TRUE,
add_noise=rgumbel)
## Subset simulated viral loads to observation times
obs_dat <- viral_loads %>%
filter(t %in% obs_times) %>%
group_by(t) %>%
sample_n(n_per_samp) %>%
select(t, obs) %>%
rename(ct=obs)
## Set up GP parameters
tmp <- prob_infection[(0:max(obs_dat$t))+1]
tmp <- pmax(0.0000001, tmp)
true_probs <- log(tmp/(1-tmp))
names <- "prob"
fixed <- 0
lower_bound <- 0
upper_bound <- 1
steps <- 0.1
lower_start <- 0
upper_start <- 0.0001
parTab_probs <- data.frame(values=true_probs,names=names,fixed=0,
lower_bound=-20,upper_bound=20,steps=0.1,
lower_start=-2,upper_start=2)
parTab <- rbind(parTab, parTab_probs)
pars <- parTab$values
names(pars) <- parTab$names
## MCMC
mcmcPars1 <- c("iterations"=100000,"popt"=0.44,"opt_freq"=5000,
"thin"=10,"adaptive_period"=50000,"save_block"=1000)
mcmcPars2 <- c("iterations"=100000,"popt"=0.234,"opt_freq"=5000,
"thin"=10,"adaptive_period"=50000,"save_block"=1000)
## Get random starting values
startTab <- generate_viable_start_pars(parTab,obs_dat,
create_posterior_func,
gaussian_process_model,
prior_func_use)
covMat <- diag(nrow(startTab))
mvrPars <- list(covMat,2.38/sqrt(nrow(startTab[startTab$fixed==0,])),w=0.8)
f <- create_posterior_func(startTab, data=obs_dat, PRIOR_FUNC=prior_func_hinge_gp,
INCIDENCE_FUNC=gaussian_process_model)
f(pars)
## Run multivariate proposal MCMC
if(rerun){
output <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars1,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=NULL,
OPT_TUNING=0.2)
chain <- read.csv(output$file)
chain <- chain[chain$sampno >= mcmcPars1["adaptive_period"],2:(ncol(chain)-1)]
covMat <- cov(chain)
covMat <- diag(nrow(startTab))
mvrPars <- list(covMat,2.38/sqrt(nrow(startTab[startTab$fixed==0,])),w=0.8)
bestPars <- get_best_pars(chain)
startTab$values <- bestPars
output1 <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars2,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=mvrPars,
OPT_TUNING=0.2)
chain <- read.csv(output1$file)
} else {
chain <- read.csv("test_multivariate_chain.csv")
}
source('~/.active-rstudio-document', echo=TRUE)
plot(coda::as.mcmc(chain))
source('~/.active-rstudio-document', echo=TRUE)
library(tidyverse)
library(ggplot2)
library(lazymcmc)
library(extraDistr)
Rcpp::compileAttributes("~/Documents/GitHub/virosolver")
devtools::document("~/Documents/GitHub/virosolver")
devtools::load_all("~/Documents/GitHub/virosolver")
source("~/Documents/GitHub/ct_inference/code/priors.R")
setwd("~/Documents/viral_load_model_test/")
rerun <- TRUE
## Parameters
parTab <- read.csv("~/Documents/GitHub/ct_inference/pars/parTab_test_seir.csv")
parTab[parTab$names == "beta","fixed"] <- 1
parTab[parTab$names == "rho","fixed"] <- 0
parTab[parTab$names == "rho","values"] <- 0.03
parTab[parTab$names == "nu","fixed"] <- 0
parTab[parTab$names == "nu","values"] <- 3
parTab[parTab$names == "t0","values"] <- 0
parTab[parTab$names == "t0","fixed"] <- 1
pars <- parTab$values
names(pars) <- parTab$names
## Observation times
obs_times <- seq(25,100,by=25)
#obs_times <- c(35, 70,105)
ages <- 1:max(obs_times)
times <- seq(0,max(obs_times),by=1)
## Epidemic cannot start after first observation time
parTab[parTab$names == "t0",c("upper_bound","upper_start")] <- min(obs_times)
## Specify process models
prior_func_use <- prior_func_hinge_gp
incidence_func <- solveSEIRModel_rlsoda_wrapper
## Number sampled per time
n_per_samp <- 1000
n_overall <- length(obs_times)*n_per_samp
## Probability of infection
pars["sigma"] <- 1/pars["incubation"]
pars["gamma"] <- 1/pars["infectious"]
pars["beta"] <- pars["R0"]*pars["gamma"]
## Simulate probability of infection
prob_infection <- incidence_func(pars, times)
#mat <- matrix(rep(times, each=length(times)),ncol=length(times))
#dist <- abs(apply(mat, 2, function(x) x-times))
#mus <- rep(0, length(times))
#nusq <- 10
#rhosq <- 0.001
#K <- nusq * exp(-rhosq * (dist)^2)
#diag(K) <- diag(K) + 0.01
#k <- mvtnorm::rmvnorm(1, mean=mus, sigma=K)[1,]
#ps <- 1/(1+exp(-k))
#prob_infection <- (ps/sum(ps))*pars["overall_prob"]
#plot(prob_infection)
## Simulate infection times
inf_times <- simulate_infection_times(n_per_samp,prob_infection)
## Simulate viral loads/ct values
viral_loads <- simulate_viral_loads(inf_times, times, pars,
additional_detect_process = TRUE,
convert_ct=TRUE,
add_noise=rgumbel)
## Subset simulated viral loads to observation times
obs_dat <- viral_loads %>%
filter(t %in% obs_times) %>%
group_by(t) %>%
sample_n(n_per_samp) %>%
select(t, obs) %>%
rename(ct=obs)
## Set up GP parameters
tmp <- prob_infection[(0:max(obs_dat$t))+1]
tmp <- pmax(0.0000001, tmp)
true_probs <- log(tmp/(1-tmp))
names <- "prob"
fixed <- 0
lower_bound <- 0
upper_bound <- 1
steps <- 0.1
lower_start <- 0
upper_start <- 0.0001
parTab_probs <- data.frame(values=true_probs,names=names,fixed=0,
lower_bound=-20,upper_bound=20,steps=0.1,
lower_start=-2,upper_start=2)
parTab <- rbind(parTab, parTab_probs)
pars <- parTab$values
names(pars) <- parTab$names
## MCMC
mcmcPars1 <- c("iterations"=100000,"popt"=0.44,"opt_freq"=5000,
"thin"=10,"adaptive_period"=50000,"save_block"=1000)
mcmcPars2 <- c("iterations"=100000,"popt"=0.234,"opt_freq"=5000,
"thin"=10,"adaptive_period"=50000,"save_block"=1000)
## Get random starting values
startTab <- generate_viable_start_pars(parTab,obs_dat,
create_posterior_func,
gaussian_process_model,
prior_func_use)
covMat <- diag(nrow(startTab))
mvrPars <- list(covMat,2.38/sqrt(nrow(startTab[startTab$fixed==0,])),w=0.8)
f <- create_posterior_func(startTab, data=obs_dat, PRIOR_FUNC=prior_func_hinge_gp,
INCIDENCE_FUNC=gaussian_process_model)
f(pars)
## Run multivariate proposal MCMC
if(rerun){
output <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars1,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=NULL,
OPT_TUNING=0.2)
chain <- read.csv(output$file)
chain <- chain[chain$sampno >= mcmcPars1["adaptive_period"],2:(ncol(chain)-1)]
covMat <- cov(chain)
covMat <- diag(nrow(startTab))
mvrPars <- list(covMat,2.38/sqrt(nrow(startTab[startTab$fixed==0,])),w=0.8)
bestPars <- get_best_pars(chain)
startTab$values <- bestPars
output1 <- run_MCMC(parTab=startTab,
data=obs_dat,
INCIDENCE_FUNC=gaussian_process_model,
PRIOR_FUNC = prior_func_hinge_gp,
solve_likelihood=TRUE,
mcmcPars=mcmcPars2,
filename="test",
CREATE_POSTERIOR_FUNC=create_posterior_func,
mvrPars=mvrPars,
OPT_TUNING=0.2)
chain <- read.csv(output1$file)
} else {
chain <- read.csv("test_multivariate_chain.csv")
}
source('~/.active-rstudio-document', echo=TRUE)
plot(quants[3,],type='l',ylim=c(0,0.03))
lines(quants[2,])
lines(quants[1,])
lines(prob_infection,col="red",lwd=2)
quad <- function(y, a, b, c){
c1 <- c - y
sol1 <- (-b + sqrt(b^2 - 4*a*c))/2*a
sol2 <- (-b - sqrt(b^2 - 4*a*c))/2*a
list(sol1, sol2)
}
quad <- function(y, a, b, c){
c1 <- c - y
sol1 <- (-b + sqrt(b^2 - 4*a*c))/2*a
sol2 <- (-b - sqrt(b^2 - 4*a*c))/2*a
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(y,a,b,c)
quad <- function(y, a, b, c){
c1 <- c - y
sol1 <- (-b + sqrt(b^2 - 4*a*c1))/2*a
sol2 <- (-b - sqrt(b^2 - 4*a*c1))/2*a
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(y,a,b,c)
quad(0,a,b,c)
quad <- function(y, a, b, c){
c1 <- c - y
print(a)
print(b)
print(c)
sol1 <- (-b + sqrt(b^2 - 4*a*c1))/2*a
sol2 <- (-b - sqrt(b^2 - 4*a*c1))/2*a
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(0,a,b,c)
quad <- function(y, a, b, c){
c1 <- c - y
print(a)
print(b)
print(c)
sol1 <- (-b + sqrt(b^2 - 4*a*c1))/2*a
sol2 <- (-b - sqrt(b^2 - 4*a*c1))/2*a
list(sol1, sol2)
}
a <- 0.002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(0,a,b,c)
quad <- function(y, a, b, c){
c1 <- c - y
print(a)
print(b)
print(c)
det <- sqrt(b^2 - 4*a*c)
sol1 <- (-b + det)/2*a
sol2 <- (-b - det)/2*a
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(0,a,b,c)
quad <- function(y, a, b, c){
c1 <- c - y
print(a)
print(b)
print(c)
det <- sqrt(b^2 - 4*a*c1)
sol1 <- (-b + det)/2*a
sol2 <- (-b - det)/2*a
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(0,a,b,c)
quad <- function(y, a, b, c){
c1 <- c - y
print(a)
print(b)
print(c)
print(c1)
det <- sqrt(b^2 - 4*a*c1)
sol1 <- (-b + det)/2*a
sol2 <- (-b - det)/2*a
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(0,a,b,c)
eq <- function(x,a,b,c){
y <- a*x^2 + b*x + c
y
}
eq(20,a,b,c)
-b
-b + sqrt(b^2 - 4*a*c)
(-b + sqrt(b^2 - 4*a*c))/2*a
2*a
0.0001/0.0002
(-b + sqrt(b^2 - 4*a*c))/(2*a)
quad <- function(y, a, b, c){
c1 <- c - y
det <- sqrt(b^2 - 4*a*c1)
sol1 <- (-b + det)/(2*a)
sol2 <- (-b - det)/(2*a)
list(sol1, sol2)
}
a <- 0.0002
b <- 0.0148
c <- -0.0048
y <- 0.3728
quad(0,a,b,c)
quad(0.3728,a,b,c)
